"""
    NURBS Python Package
    Licensed under MIT License
    Developed by Onur Rauf Bingol (c) 2016-2017
"""

import decimal


# Implementation of http://stackoverflow.com/a/7267280
def frange(x, y, step):
    step_str = str(step)
    while x <= y:
        yield float(x)
        x += decimal.Decimal(step_str)


def normalize_knotvector(knotvector=()):
    if len(knotvector) == 0:
        return knotvector

    first_knot = float(knotvector[0])
    last_knot = float(knotvector[-1])

    knotvector_out = []
    for kv in knotvector:
        knotvector_out.append((float(kv) - first_knot) / (last_knot - first_knot))

    return knotvector_out


def autogen_knotvector(degree=0, num_ctrlpts=0):
    if degree == 0 or num_ctrlpts == 0:
        raise ValueError("Inputs should be different than zero")

    # Min and max knot vector values
    knot_min = 0.0
    knot_max = 1.0

    # Equation to use: m = n + p + 1
    # p: degree, n+1: number of ctrlpts; m+1: number of knots
    m = degree + num_ctrlpts + 1

    # Initialize return value and counter
    knotvector = []
    i = 0

    # First degree+1 knots are "knot_min"
    while i < degree+1:
        knotvector.append(knot_min)
        i += 1

    # Calculate a uniform interval for middle knots
    num_segments = (m - (degree+1)*2)+1  # number of segments in the middle
    spacing = (knot_max - knot_min) / num_segments  # spacing between the knots (uniform)
    midknot = knot_min + spacing  # first middle knot
    # Middle knots
    while i < m-(degree+1):
        knotvector.append(midknot)
        midknot += spacing
        i += 1

    # Last degree+1 knots are "knot_max"
    while i < m:
        knotvector.append(knot_max)
        i += 1

    # Return autogenerated knot vector
    return knotvector


# Algorithm A2.1
def find_span(degree=0, knotvector=(), knot=0):
    # Number of knots; m + 1
    # Number of basis functions, n +1
    # n = m - p - 1; where p = degree
    m = len(knotvector) - 1
    n = m - degree - 1
    if knotvector[n + 1] == knot:
        return n

    low = degree
    high = n + 1
    mid = int((low + high) / 2)

    while (knot < knotvector[mid]) or (knot >= knotvector[mid + 1]):
        if knot < knotvector[mid]:
            high = mid
        else:
            low = mid
        mid = int((low + high) / 2)

    return mid


# Algorithm A2.2
def basis_functions(degree=0, knotvector=(), span=0, knot=0):
    left = [0.0] * (degree+1)
    right = [0.0] * (degree+1)

    # N[0] = 1.0 by definition
    bfuncs_out = [1.0]

    j = 1
    while j <= degree:
        left[j] = knot - knotvector[span+1-j]
        right[j] = knotvector[span+j] - knot
        saved = 0.0
        r = 0
        while r < j:
            temp = bfuncs_out[r] / (right[r+1] + left[j-r])
            bfuncs_out[r] = saved + right[r+1] * temp
            saved = left[j-r] * temp
            r += 1
        bfuncs_out.append(saved)
        j += 1

    return bfuncs_out


def check_uv(u=-1, v=-1, delta=0.1, test_normal=False):
    pass



